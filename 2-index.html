<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>АПБ Судейская Панель</title>
    
    <!-- PWA & Mobile Optimization -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#ffffff">
    
    <!-- Ссылка на манифест -->
    <link rel="manifest" href="manifest.json">
     <!-- Фавиконы -->
    <!-- SVG иконка (основная для современных браузеров) -->
    <link rel="icon" type="image/svg+xml" href="icons/favicon.svg">
    <!-- Запасной вариант (PNG) -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-72.png">
    <!-- Иконка для iOS -->
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet">

    <style>
        body {
            background-color: #F8F8F8;
            margin: 0;
            overscroll-behavior-y: contain;
            -webkit-tap-highlight-color: transparent;
        }
        * {
            font-family: 'Inter', sans-serif !important;
            -webkit-font-smoothing: antialiased;
        }
        .material-symbols-outlined {
            font-family: 'Material Symbols Outlined' !important;
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .glass {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        @keyframes zoom-blur-out {
            0% { transform: scale(1); filter: blur(0px); opacity: 1; }
            100% { transform: scale(1.5); filter: blur(20px); opacity: 0; }
        }
        .loader-ring {
            width: 32px;
            height: 32px;
            border: 2px solid rgba(0,0,0,0.05);
            border-top: 2px solid #000;
            border-radius: 50%;
            animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        }
        .preloader-exit {
            animation: zoom-blur-out 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            pointer-events: none;
        }
        @keyframes card-appear {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .card-animate {
            animation: card-appear 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }
        video::-webkit-media-controls {
            display:none !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Регистрация Service Worker для PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered'))
                    .catch(err => console.log('SW registration failed', err));
            });
        }

        // --- Прелоадер ---
        const Preloader = ({ onComplete }) => {
            const [isExiting, setIsExiting] = useState(false);
            useEffect(() => {
                const timer = setTimeout(() => {
                    setIsExiting(true);
                    setTimeout(onComplete, 800); 
                }, 2500);
                return () => clearTimeout(timer);
            }, [onComplete]);

            return (
                <div className={`fixed inset-0 z-[9999] bg-white flex flex-col items-center justify-center ${isExiting ? 'preloader-exit' : ''}`}>
                    <div className="mb-8 text-black">
                        <svg width="120" height="120" viewBox="0 0 96 96" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#3171af" width="96" height="96" rx="9.24" ry="9.24"/>
  
  <g fill="#ffffff">
    <path d="M33.12,78.03h-3.23l-1.28-2.88h-5.88l-1.21,2.88h-3.15l5.73-12.67h3.14l5.89,12.67Zm-5.47-5.01l-2.03-4.7-1.99,4.7h4.01Z"/>
    <path d="M34.8,65.36h11.7v12.67h-2.97v-10.55h-5.76v10.55h-2.97v-12.67Z"/>
    <path d="M49.91,65.36h10.99v2.13h-8.02v2.94h3.97c1.1,0,2.01,.12,2.73,.35,.72,.23,1.34,.66,1.85,1.28s.77,1.35,.77,2.19-.26,1.59-.77,2.2c-.52,.61-1.1,1.03-1.76,1.25-.66,.22-1.6,.34-2.81,.34h-6.94v-12.67Zm2.97,10.55h2.89c.92,0,1.57-.04,1.95-.12,.37-.08,.7-.26,.98-.53,.28-.28,.42-.62,.42-1.02,0-.59-.24-1.02-.73-1.28-.48-.27-1.31-.4-2.48-.4h-3.02v3.35Z"/>
  </g>

  <path fill="#ffffff" d="M81.8,13.1V82.9H14.2V13.1H81.8m3.9-4.03H10.3V86.92H85.7V9.08h0Z"/>
</svg>

                    </div>
                    <div className="loader-ring"></div>
                    <p className="mt-6 text-[10px] font-medium uppercase tracking-[0.3em] text-black opacity-40">АПБ судейская панель</p>
                </div>
            );
        };

        const Icon = ({ name, className = "", size = 20 }) => (
            <span className={`material-symbols-outlined ${className}`} style={{ fontSize: size }}>
                {name}
            </span>
        );

        function App() {
            const [loading, setLoading] = useState(true);
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [authStep, setAuthStep] = useState(1); 
            const [tempJudgeName, setTempJudgeName] = useState('');
            const [selectedCity, setSelectedCity] = useState('Москва');
            const [isCityOpen, setIsCityOpen] = useState(false);
            const [accessKey, setAccessKey] = useState('');
            const [authError, setAuthError] = useState('');

            const [judgeName, setJudgeName] = useState('');
            const [eventCity, setEventCity] = useState('');
            const [discipline, setDiscipline] = useState('Разметка');
            const [isDisciplineOpen, setIsDisciplineOpen] = useState(false);
            
            const [allData, setAllData] = useState({});
            const [submittedDisciplines, setSubmittedDisciplines] = useState([]);
            const [history, setHistory] = useState([]);
            
            const [openSelect, setOpenSelect] = useState({ id: null, type: null });
            const [fullscreenNote, setFullscreenNote] = useState(null); 
            const [toast, setToast] = useState(null);
            const [isRecording, setIsRecording] = useState(null);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [isHistoryOpen, setIsHistoryOpen] = useState(false);

            const [editJudgeName, setEditJudgeName] = useState('');
            const [editAccessKey, setEditAccessKey] = useState('');

            const [activeCamera, setActiveCamera] = useState(null);
            const [facingMode, setFacingMode] = useState('environment');
            const [stream, setStream] = useState(null);
            const videoRef = useRef(null);

            const cities = ['Москва', 'Пермь', 'Екатеринбург', 'Санкт-Петербург','Ростов-на-Дону'];
            const disciplines = [
    'Разметка', 'Смешка канекалона', 'Рисунок из брейдов', 'Вплетение комплекта кос',
    'Боксерские косы', 'Водопад', 'Брейды в хвост', 'Цветной ряд',
    'Наращивание на микро-косы', 'Каркасные прически', 'Термозамещение', 'Точечные косы',
    'Брейды без материала', 'Брейды с материалом', 'Микс-прически', 'Технический комплект',
    'Натуральные дреды', 'Подплетение нат. дредов', 'Творческие номинации', 'Секретная номинация',
    'Изделие из канекалона', 'Креативная причёска', 'Творческие боксерские косы', 'Творческий водопад',
    'Творческие брейды в хвост', 'Творческий комплект', 'Женский образ', 'Мужской образ',
    'Детский образ', 'Командная работа'
];
            const participantNumbers = Array.from({ length: 100 }, (_, i) => i.toString().padStart(2, '0'));

            useEffect(() => {
                const saved = localStorage.getItem('judging_app_v5_data');
                const savedSubmitted = localStorage.getItem('judging_app_v5_submitted');
                const savedHistory = localStorage.getItem('judging_app_v5_history');
                const savedProfile = localStorage.getItem('judging_app_v5_profile');

                if (saved) setAllData(JSON.parse(saved));
                if (savedSubmitted) setSubmittedDisciplines(JSON.parse(savedSubmitted));
                if (savedHistory) setHistory(JSON.parse(savedHistory));
                
                if (savedProfile) {
                    const profile = JSON.parse(savedProfile);
                    setJudgeName(profile.name);
                    setAccessKey(profile.key);
                    setEditJudgeName(profile.name);
                    setEditAccessKey(profile.key);
                    setEventCity(profile.city || 'Москва');
                    setIsAuthenticated(true);
                }
            }, []);

            useEffect(() => {
                if (isAuthenticated) {
                    localStorage.setItem('judging_app_v5_data', JSON.stringify(allData));
                    localStorage.setItem('judging_app_v5_submitted', JSON.stringify(submittedDisciplines));
                    localStorage.setItem('judging_app_v5_history', JSON.stringify(history));
                }
            }, [allData, submittedDisciplines, history, isAuthenticated]);

            const showToast = (message) => {
                setToast(message);
                setTimeout(() => setToast(null), 2500);
            };

            const handleAuth = () => {
                if (accessKey === '1111' || (editAccessKey && accessKey === editAccessKey)) {
                    const finalName = tempJudgeName || editJudgeName || 'Судья';
                    setJudgeName(finalName);
                    setEventCity(selectedCity);
                    setEditJudgeName(finalName);
                    setEditAccessKey(accessKey);
                    setIsAuthenticated(true);
                    localStorage.setItem('judging_app_v5_profile', JSON.stringify({ name: finalName, key: accessKey, city: selectedCity }));
                } else {
                    setAuthError('Неверный ключ доступа');
                }
            };

            const handleSaveSettings = () => {
                setJudgeName(editJudgeName);
                setAccessKey(editAccessKey);
                localStorage.setItem('judging_app_v5_profile', JSON.stringify({ name: editJudgeName, key: editAccessKey, city: eventCity }));
                setIsSettingsOpen(false);
                showToast('Настройки сохранены');
            };

            const participants = allData[discipline] || [{ id: '1', number: '00', comment: '', photos: [], score: null }];
            const isCurrentSubmitted = submittedDisciplines.includes(discipline);
            
            const availableScores = Array.from({ length: participants.length }, (_, i) => 30 - i);
            const occupiedScores = participants.map(p => p.score).filter(s => s !== null);
            const allOccupiedNumbers = Object.values(allData).flat().map(p => p.number);

            const setParticipants = (newParticipants) => {
                if (isCurrentSubmitted) return;
                const updater = typeof newParticipants === 'function' ? newParticipants(participants) : newParticipants;
                
                const nextParticipants = updater.map(p => {
                    const newMaxLen = updater.length;
                    const lowestAllowed = 30 - (newMaxLen - 1);
                    if (p.score !== null && p.score < lowestAllowed) {
                        return { ...p, score: null };
                    }
                    return p;
                });
                setAllData(prev => ({ ...prev, [discipline]: nextParticipants }));
            };

            const handleSendReport = () => {
                if (submittedDisciplines.includes(discipline)) return;
                const now = new Date();
                const timestamp = `${now.toLocaleDateString()} ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                const newHistoryEntries = participants.map(p => ({
                    date: timestamp,
                    discipline: discipline,
                    participantId: p.number,
                    score: p.score
                }));
                setHistory(prev => [...newHistoryEntries, ...prev]);
                setSubmittedDisciplines(prev => [...prev, discipline]);
                showToast('Отчет успешно отправлен');
            };


            const startCamera = async (id) => {
                if (isCurrentSubmitted) return;
                setActiveCamera(id);
                try {
                    if (stream) stream.getTracks().forEach(track => track.stop());
                    const constraints = {
                        video: { 
                            facingMode: { ideal: facingMode }, 
                            width: { ideal: 1920 }, // Просим высокое разрешение
                            height: { ideal: 1080 } 
                        },
                        audio: false
                    };
                    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    setStream(mediaStream);
                    setTimeout(() => {
                        if (videoRef.current) {
                            videoRef.current.srcObject = mediaStream;
                        }
                    }, 100);
                } catch (err) { 
                    setActiveCamera(null);
                    showToast('Ошибка доступа к камере');
                }
            };

            // Исправленная функция захвата фото с коррекцией ориентации и кадрированием
            const takePhoto = () => {
                if (!videoRef.current || isCurrentSubmitted) return;
                
                const video = videoRef.current;
                const canvas = document.createElement('canvas');
                
                // Получаем реальные размеры видеопотока
                const vWidth = video.videoWidth;
                const vHeight = video.videoHeight;
                
                // Целевые пропорции (вертикальные, как экран телефона)
                const targetWidth = 1080;
                const targetHeight = 1920;
                const targetRatio = targetWidth / targetHeight;

                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');

                // Расчет области обрезки (Crop), чтобы имитировать object-cover
                let sourceX, sourceY, sourceWidth, sourceHeight;
                const videoRatio = vWidth / vHeight;

                if (videoRatio > targetRatio) {
                    // Видео шире чем нужно (горизонтальное) -> режем по бокам
                    sourceHeight = vHeight;
                    sourceWidth = vHeight * targetRatio;
                    sourceX = (vWidth - sourceWidth) / 2;
                    sourceY = 0;
                } else {
                    // Видео уже чем нужно (вертикальное, но других пропорций) -> режем сверху/снизу
                    sourceWidth = vWidth;
                    sourceHeight = vWidth / targetRatio;
                    sourceX = 0;
                    sourceY = (vHeight - sourceHeight) / 2;
                }

                // Отражение для фронтальной камеры
                if (facingMode === 'user') {
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                }

                // Рисуем обрезанную и масштабированную часть видео
                ctx.drawImage(
                    video, 
                    sourceX, sourceY, sourceWidth, sourceHeight, // Откуда берем
                    0, 0, targetWidth, targetHeight             // Куда рисуем
                );

                const photoUrl = canvas.toDataURL('image/jpeg', 0.85);
                setParticipants(prev => prev.map(p => p.id === activeCamera ? { ...p, photos: [...p.photos, photoUrl] } : p));
                stopCamera();
            };

            const stopCamera = () => {
                if (stream) stream.getTracks().forEach(track => track.stop());
                setStream(null);
                setActiveCamera(null);
            };

            const toggleFacingMode = () => {
                setFacingMode(prev => prev === 'user' ? 'environment' : 'user');
                stopCamera();
            };

            const updateParticipant = (id, field, value) => {
                if (isCurrentSubmitted) return;
                if (field === 'score' && value !== null && occupiedScores.includes(value)) {
                    showToast('Оценка уже занята'); return;
                }
                if (field === 'number' && value !== '00' && allOccupiedNumbers.includes(value)) {
                    showToast('ID уже используется'); return;
                }
                setParticipants(participants.map(p => p.id === id ? { ...p, [field]: value } : p));
                setOpenSelect({ id: null, type: null });
            };

            const isReadyToSave = participants.length > 0 && participants.every(p => p.score !== null && p.number !== '00');

            if (loading) return <Preloader onComplete={() => setLoading(false)} />;

            if (!isAuthenticated) {
                return (
                    <div className="min-h-screen bg-white flex flex-col items-center justify-center px-8">
                        <div className="w-full max-w-sm space-y-10">
                            <div className="text-center space-y-2">
                                <h1 className="text-2xl font-light tracking-tight text-black">Авторизация</h1>
                                <p className="text-[10px] text-gray-400 font-medium uppercase tracking-[0.3em]">Судейская панель АПБ</p>
                            </div>
                            <div className="space-y-6">
                                {authStep === 1 ? (
                                    <div className="space-y-5">
                                        <div className="space-y-4">
                                            <div className="relative">
                                                <Icon name="person" className="absolute left-0 top-1/2 -translate-y-1/2 text-gray-300" size={20} />
                                                <input type="text" placeholder="Имя судьи" value={tempJudgeName} onChange={(e) => setTempJudgeName(e.target.value)} className="w-full bg-transparent border-b border-gray-100 py-3 pl-8 text-base font-light outline-none focus:border-black transition-colors" />
                                            </div>
                                            <div className="relative">
                                                <Icon name="location_on" className="absolute left-0 top-1/2 -translate-y-1/2 text-gray-300" size={20} />
                                                <button onClick={() => setIsCityOpen(!isCityOpen)} className="w-full bg-transparent border-b border-gray-100 py-3 pl-8 text-base text-left font-light outline-none flex justify-between items-cen
